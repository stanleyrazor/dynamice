# functions.R
# Main functions for running the DynaMICE model

# ------------------------------------------------------------------------------
# Measles vaccine impact model
#   To estimate the health impact of measles vaccination for a given set of
#   countries.
# ------------------------------------------------------------------------------


# ------------------------------------------------------------------------------
#' Execute the fortran model for a country and a PSA run
#'
#' A function nested under \code{\link{runScenario}} to run the fortran codes
#'  for measles vaccination, given a particular country and a variable set of
#'  probabilistic sensitivity analysis (PSA).
# ------------------------------------------------------------------------------
# Changes 2019:
# 1) expanded matrix is rescaled to keep the total number of
# contacts in weekly age groups correct (checked - R0 of rescaled matrix is now
# the same as prior to expanding it to weekly ages)
# 2) projects the contact matrix to represent country's demography
# ------------------------------------------------------------------------------
#' @param ii Numeric order of the selected country for evaluation.
#' @param iso3 ISO-3 code of the selected country.
#' @param years A vector containing continuous calender years for simulation.
#' @param vaccination A numeric indicator that determines vaccination programmes
#'  for children: 0 - No vaccination, 1 - Only MCV1,  2 - MCV1 and MCV2.
#' @param using_sia A numeric indicator that determines whether supplementary
#' immunisation activities (SIAs) are implemented: 0 - no SIA, 1 - with SIA.
#' @param dinf Duration of infection in days.
#' @param gamma_tstep Recovery rate, with a unit of 1/(\code{dinf}*\code{tstep}*year).
#' @param amplitude A numeric variable for amplitude of seasonality.
#' @param take A 1*3 vector that denotes the level of vaccine protection using
#' the 'take' ('all-or-not') assumption. Vaccine protection is assumed to vary
#' by age under a linear regression, with (1) and (2) elements of the vector
#' representing the intercept and coefficient of the first dose, respectively.
#' (3) element represents the vaccine protection by the second dose. Note that
#' in the previous fortran model without the incorporation of age-related
#' regression model, (1) and (2) elements reflected the protection of the first
#' dose before and after 1 year old, respectively.
#' @param degree A 1*3 vector that denotes the level of vaccine protection using
#'  the 'degree' ('leak') assumption. (1) and (2) elements represents the
#'  protection of the first dose before and after 1 year old, respectively, and
#' (3) element shows that of the second dose. Note that the second dose only has
#'  an effect if \code{vaccine=2}.
#' @param sia.method A numeric indicator that determines how SIAs are carried
#' out: 1 - varying \code{take}, 2 - varying \code{degree}.
#' @param c_coverage_routine A data frame for routine vaccination coverage under
#' a selected scenario for a specific country.
#' @param c_coverage_sia A data frame for SIA coverage under a selected scenario
#'  for a specific country.
#' @param c_timeliness A data frame for timeliness estimates by age for a
#' specific country.
#' @param contact_mat A character variable that indicates the assumptions for
#' contact patterns. "prpmix" - proportional mixing informed by age distribution
#' of population, "unimix" -  uniform mixing (equal mixing probability across
#' each age year), "polymod" - POLYMOD Great Britain physical contacts expanded
#' using local populations, and "syn" - country-specific synthetic matrix.
#' @param c_contact A data frame for the contact matrix by age (0-100 years old)
#'  for a specific country.
#' @param c_rnought A numeric variable of R0 value for the selected country
#' \code{iso3}. Estimates provided by Ferrari and colleagues.
#' @param c_population A data frame for population size by age for a specific
#' country.
#' @param tstep Simulation time steps for each year.
#' @param save_scenario A folder name of the selected scenario.
#' @param foldername A folder name for input and output files of the selected
#' scenario. It typically does not exist but may come in handy when only
#' processing results.
#' @param log_name A file name for keeping a log.
#' @param measles_model An executable file that processes fortan codes of the
#' measles model.
#' @param debug_model A logical variable that determines whether to debug the
#' model.
#' @param debug_spinup A logical variable that determines whether to generate
#' outputs for the spin-up (equilibrium) period.
#' @param debug_age A numeric variable that determines the format of output age
#' groups: 0 - all in annual age-strata, 1 - age between 0 and 2 in weekly
#' age-strata and age between 3 and 100 in annual age-strata.
#' @param debug_compartments A numeric variable that determines the compartments
#' to output: 0 - number of cases, and 1 - each compartment.
#' @param debug_country A vector including ISO3 country codes for countries to
#' be included for debugging, or *
#' to debug all countries.
#' @param debug_relative A logical variable that determines the output format of
#' new cases: TRUE - proportion, and FALSE - absolute number.
#' @param debug_timepoints A logical variable that determines the output unit of
#' time: 0 - per year, 1 - per timepoint and report first 25% of timepoints, and
#' 2 - per timepoint and report all timepoints.
#' @param r A numeric variable of the order of the PSA runs.
#' @param runs A numeric variable of the total runs for each scenario.
#' @param psa A numeric variable of the total runs for PSA. Use 0 to indicate a
#' single run without PSA.
#' @param psa_var A data frame including the parameter values used in PSA.
#' @param run_model A logical variable that determines whether to run the
#' measles model.
#' @param remove_files A logical variable that determines whether to remove
#' output files after finishing a single country run.
#'
#' @import data.table
#'
#' @examples
#' \dontrun{
#' runCountry (
#'   ii                 = 2,
#'   iso3               = "BGD",
#'   years              = 1980:2020,
#'   vaccination        = 1,
#'   using_sia          = 1,
#'   dinf               = 14,
#'   gamma_tstep        = 0.02607,
#'   amplitude          = 0.05,
#'   take               = c(0.64598, 0.01485, 0.98),
#'   degree             = c(0.85, 0.95, 0.98),
#'   sia.method         = 1,
#'   c_coverage_routine = coverage_routine[country_code == "BGD"],
#'   c_coverage_sia     = coverage_sia[country_code == "BGD" & coverage!=0],
#'   c_timeliness       = timeliness[country_code == "BGD"],
#'   contact_mat        = "prpmix",
#'   c_contact          = contact[["BGD"]],
#'   c_rnought          = 10,
#'   c_population       = population[country_code == "BGD"],
#'   tstep              = 1000,
#'   save_scenario      = "scenario01",
#'   foldername         = NULL,
#'   log_name           = "test_log",
#'   measles_model      = "vaccine2019_sia_singlematrix.exe",
#'   debug_model        = FALSE,
#'   debug_spinup       = FALSE,
#'   debug_age          = 0,
#'   debug_compartments = 1,
#'   debug_country      = "*",
#'   debug_relative     = FALSE,
#'   debug_timepoints   = 0,
#'   r                  = 1,
#'   runs               = 1,
#'   psa                = 0,
#'   psa_var            = psa_var,
#'   run_model          = TRUE,
#'   remove_files       = FALSE
#'   )
#'   }
runCountry <- function (
  #variables specific for loop
  ii,
  iso3,
  years,

  #infection dynamic variables
  vaccination,
  using_sia,
  dinf,
  gamma_tstep,
  amplitude,
  take,
  degree,
  sia.method,

  #input data
  c_coverage_routine,
  c_coverage_sia,
  c_timeliness,
  contact_mat,
  c_contact,
  c_rnought,
  c_population,

  # dynaMICE model options
  tstep,
  save_scenario,
  foldername,
  measles_model,
  log_name,
  debug_model,
  debug_spinup,
  debug_age,
  debug_compartments,
  debug_country,
  debug_relative,
  debug_timepoints,

  # PSA options
  r,
  runs,
  psa,
  psa_var,  # used only when psa > 0

  #additional options
  run_model,
  remove_files = F # added by Han
) {


  # temporarily assign 3-letter-ISO code to Kosovo until Kosovo is assigned official ISO3-code
  {if (iso3 == "XK"){
    fortran_country_code <- "XKX"
  } else {
    fortran_country_code <- iso3
  }}

  {if (psa > 0) {
    p <- r
    if(p<10){
      p <- paste0("00",p)
    } else if(p<100){
      p <- paste0("0",p)
    }
    psadir <- paste0("run",p,"/")
  } else {
    psadir <- ""
  }}

  if (run_model) {

    {if ((using_sia == 1) & (nrow (c_coverage_sia) > 0)) {

      sia_a0       <- c_coverage_sia [, a0]
      sia_year     <- c_coverage_sia [, year]
      sia_a1       <- c_coverage_sia [, a1]
      sia_coverage <- c_coverage_sia [, coverage]

      sia_coverage [which (sia_coverage>1)] <- 0.95

      } else {

        sia_a0 			 <- 0
        sia_a1 			 <- 0
        sia_coverage <- 0
        sia_year 		 <- years[1]
      }}

    # t_cov is x year of model (model is ran for t_cov timesteps)
    t_cov <- length(years) * tstep
    t_end <- t_cov * 2

    # t_run: for each year that is modelled,  get timepoint at which the year starts
    t_run <- t_end - (length(years):1) * tstep + 1

    # get timepoints for SIAs, assumed to take place at the beginning of a calendar year
    # for multiple SIA entries within a single year in a county:
    # if they are entries of mutually exclusive age groups, assume occurring at a single timestep
    # if they are different SIA rounds, assume occurring at a specified interval ex. 1 month (tstep/12)

    t_sia <- unlist (sapply (sort (unique (sia_year)), function (iyr, sia_year)
      return (t_run[1] + tstep * (iyr - years[1]) + c(1:sum(sia_year == iyr) + round(tstep/12))),
      sia_year = sia_year
      ))

    {if (using_sia == 0) {
      t_sia <- t_sia*-1
    }}

    print(paste0("Generating data for model: ", iso3))
    dynamice:::writelog (log_name, paste0 (iso3, "; Run ",r,"/",runs,"; Start generating data"))
    # updateProgress (iso3, ii, runs, r, 1)

    # Vaccine parameters
    {if (psa > 0) {
      take <- as.numeric (psa_var [r, c("take1_input",
                                        "take2_input",
                                        "take3_input")])
    }}

    # vaccine take
    take1 <- c (take[1], 0)[sia.method]    # vaccine take (dose 1, before age 1)
    take2 <- c (take[2], 0)[sia.method]    # vaccine take (dose 1, after age 1)
    take3 <- c (take[3], 0)[sia.method]    # vaccine take (dose 2)

    # vaccine degree
    degree1 <- c(0, degree[1])[sia.method]  # vaccine degree (dose 1, before age 1)
    degree2 <- c(0, degree[2])[sia.method]  # vaccine degree (dose 1, after age 1)
    degree3 <- c(0, degree[3])[sia.method]  # vaccine degree (dose 2)

    # country specific timeliness curve
    country_timeliness <- c_timeliness [!is.na(age), timeliness]
    timeliness_ages    <- c_timeliness [!is.na(age), age]

    # expand 0-2 years old to weekly age strata
    s         <- 52 # number of finer stages within an age band (weekly ages, so 52)
    jt        <- 3  # how many ages to expand to s (or to weeks)
    beta_full <- matrix (0,
                        ncol = 254,
                        nrow = 254)

    beta_full[(1:(s*jt)), (1:(s*jt))] <- expandMatrix (
      A = c_contact [1:jt, 1:jt]/s,  # needs to be divided by 52 so that the mean total number of contacts stays the same
      expand_rows =  s, expand_cols =  s,
      rescale_rows = FALSE, rescale_cols = FALSE)

    beta_full[1:(s*jt),((s*jt)+1):(ncol(beta_full))] <- expandMatrix(
      A = c_contact [1:jt,(jt+1):ncol(c_contact)],
      expand_rows = s, expand_cols = 1,
      rescale_rows = F, rescale_cols = F)

    beta_full[((s*jt)+1):(nrow(beta_full)), 1:(s*jt)] <- expandMatrix(
      A = c_contact [(jt+1):nrow(c_contact),1:jt]/s,  # adjust to ensure the mean total number of contacts stays the same
      expand_rows = 1, expand_cols = s,
      rescale_rows = F, rescale_cols = F)

    beta_full[((s*jt)+1):(nrow(beta_full)), ((s*jt)+1):(ncol(beta_full))] <-
      c_contact [(jt+1):nrow(c_contact),(jt+1):ncol(c_contact)]

    beta_full_unadj <- beta_full

    # infection rate under target R0
    beta_tstep  <- (c_rnought/dinf)*(365/tstep)

    # # make the matrix reciprocal by assuming uniform age distributions
    # beta_full <- (beta_full + t(beta_full)) / 2
    #
    # # make sure the R0 is what it should be
    # beta_full <- (beta_tstep / Re(eigen(beta_full, only.values=T)$values[1])) * beta_full
    #
    # # prepare input of a fixed matrix overtime
    # beta_file <- paste0 ("outcome/", save_scenario, "/",  foldername, "/input/",
    #                       psadir, fortran_country_code, "_001beta.txt")
    #
    # fwrite(
    #   as.list(
    #     as.data.table(
    #       format(
    #         beta_full,
    #         digits=14,
    #         scientific=FALSE
    #       )
    #     )
    #   ),
    #   beta_file,
    #   quote=FALSE,
    #   row.names=FALSE,
    #   col.names=FALSE,
    #   sep=" "
    # )
    #
    # # # Reduce file-writes
    # # # [method used before 2019 run] adjust using age distribution of population
    # # # beta_full_country <- (beta_full + t(beta_full)*(pop.vector_full%*%t(1/pop.vector_full)))/2
    # # # beta_full <- sweep(beta_full, 2, pop.vector_full, "/") # these are the infection rates from Wallinga et al
    # # # here, rows should be divided by the appropriate population vector, not columns, but Fortran uses rows, rather than columns to calculate force of infection so it works out.


    # --------------------------------------------------------------------------
    # generate fortran input files for each year
    # --------------------------------------------------------------------------
    for (y in years) {

      #old script groups those aged 70-80, but division is by actual population size
      pop.vector <- c_population |>
        filter(year == y) |>
        arrange(age_from) |>
        pull(value)
      #* was: pop.vector <- c_population[year == y, value]

      # first expand polymod matrix (contact_tstep) and population vector and
      # then divide by population sizes, otherwise it doesn't work.
      pop.vector_full <- c(rep(pop.vector[1:jt]/s, each = s), pop.vector[(jt +1):length(pop.vector)])

      # change zero values to 1 to avoid division by 0
      pop.vector_full[pop.vector_full==0] <- 1

      # generate contact matrices for DynaMICE using uniform age structure
      # adjust contact reciprocity by population structure of each year
      if (contact_mat == "unimix") {

        beta_full <- beta_tstep * beta_full_unadj

        } else if (contact_mat == "prpmix") {

        beta_full <- beta_tstep * matrix (rep(pop.vector_full/sum(pop.vector_full), each = 254), nrow = 254)

        } else {

        beta_full <- matrix(0, 254, 254)
        beta_full_R0 <- matrix(0, 254, 254)
        for (i in 1:254){
          for (j in 1:254) {
            beta_full [i, j] <- (beta_full_unadj[i, j] * pop.vector_full[i] +
                                   beta_full_unadj[j, i] * pop.vector_full[j])/(2*pop.vector_full[i])

            # calculate infection rate of the contact matrix based on the R0 definition
            # transform from "contactees per contactor" to "contactors per contactee"
            # This step can be skipped, since the largest eigenvalue remains unchanged.
            beta_full_R0 [i, j] <-  beta_full [i, j] * (pop.vector_full[i] / pop.vector_full[j])
          }
        }
        # make sure the contact matrix to represent target R0
        beta_full <- (beta_tstep / Re(eigen(beta_full_R0, only.values=T)$values[1])) * beta_full
      }


      if (vaccination >= 1) {

        # Maximum coverage can (obviously) only be 100%
        # To estimate proportion that is vaccinated at each week, we first calculate the number of individuals remaining susceptible
        # Then we calculate the number of individuals that should be vaccinated each week, in order to remain 1 - coverage susceptibles at the end of the timeliness data
        # In essence, this becomes the inverse of the cumulative timeliness curve
        cycov <- c_coverage_routine [year == y & vaccine == "MCV1", coverage] /
          c_timeliness [is.na(age), prop_final_cov]

        {if (length(cycov) == 0) {   # check if vaccine is not yet introduced and thereby, coverage value missing for this year
          cycov <- 0
        } else if (is.na(cycov)) {
          cycov <- 0
        }}

        country_year_timeliness_mcv1 <- 1 - min(cycov,1) * country_timeliness

        country_year_timeliness_mcv1 <- -diff(country_year_timeliness_mcv1) /
          (country_year_timeliness_mcv1 [1:(length(country_year_timeliness_mcv1)-1)])

        # Timeliness is reported by week in the first year, and by month in the second year. Assume there is no vaccination in between
        country_year_timeliness_mcv1 [is.na(country_year_timeliness_mcv1)] <- 0
        country_year_timeliness_mcv1 [is.nan(country_year_timeliness_mcv1)] <- 0
        country_year_timeliness_mcv1_allages <- rep(0, 254)
        country_year_timeliness_mcv1_allages [round(timeliness_ages)] <- country_year_timeliness_mcv1

      } else {
        country_year_timeliness_mcv1_allages <- rep(0, 254)
      }

      if(vaccination == 2){
        country_year_mcv2 <- c_coverage_routine [year == y & vaccine == "MCV2", coverage]
      } else {
        country_year_mcv2 <- 0
      }

      if ( length (country_year_mcv2) == 0 | is.na(country_year_mcv2) ) {
        country_year_mcv2 <- 0
      }


      # write data for each year
      iyr <- which (years == y)
      beta_path <- paste0 ("outcome/", save_scenario, "/", foldername,
                           "/input/", psadir, fortran_country_code)

      {if (iyr<10) {
        dynamice_input_file <- paste0 (beta_path, "_00", iyr, "measle_data.txt")
        beta_file <- paste0 (beta_path, "_00", iyr, "beta.txt")

      } else if(iyr<100) {
        dynamice_input_file <- paste0 (beta_path,  "_0", iyr, "measle_data.txt")
        beta_file <- paste0 (beta_path, "_0", iyr, "beta.txt")

      } else {
        dynamice_input_file <- paste0 (beta_path,   "_", iyr, "measle_data.txt")
        beta_file <- paste0 (beta_path, "_", iyr, "beta.txt")
      }}

      fwrite(
        as.list(
          as.data.table(
            format(
              beta_full,
              digits=14,
              scientific=FALSE
            )
          )
        ),
        beta_file,
        quote=FALSE,
        row.names=FALSE,
        col.names=FALSE,
        sep=" "
      )

      dynamice_input_vector <- c(
        t_end,
        1,
        gamma_tstep,
        tstep,
        take1,
        take2,
        take3,
        degree1,
        degree2,
        degree3,
        length(sia_a0),
        sia_a0,
        c_rnought,
        amplitude,
        1,
        length(sia_a1),
        sia_a1,
        t_end,
        t_cov,
        length(t_sia),
        t_sia,
        length(country_year_timeliness_mcv1_allages),
        country_year_timeliness_mcv1_allages,
        country_year_mcv2,
        length(sia_coverage),
        sia_coverage,
        length(t_run),
        t_run,
        format(
          pop.vector_full,
          digits=14
        )
      )

      fwrite (
        list ("a"=dynamice_input_vector),
        file = dynamice_input_file,
        col.names = FALSE
      )
    }


    # --------------------------------------------------------------------------
    # run actual model
    # --------------------------------------------------------------------------
    {if (psa == 0) {
      p <- 0
    } else {
      p <- r
    }}
    dynamice:::writelog (log_name, paste0(iso3, "; Run ",r,"/",runs,"; Finished generating data"))

    # process debugging options
    {if (debug_country != "*" & !(iso3 %in% debug_country)){
      debug_debug			    <- 0
      debug_compartments	<- 0
      debug_age		       	<- 0
      debug_timepoints  	<- 0
      debug_relative	  	<- 0
    } else {
      debug_debug 	     	<- as.integer (debug_spinup) + 2 * as.integer(debug_model)
      debug_compartments	<- as.integer (debug_compartments)
      debug_relative		  <- as.integer (debug_relative)
    }}

    # run the model
    dynamice:::writelog (log_name,paste0(iso3, "; Run ",r,"/",runs,"; Start model"))
    # updateProgress (iso3, ii, runs, r, 2)

    if(Sys.info()[["sysname"]] == "Windows"){
      model <- paste0(
        'cd "',
        'model/compiled/" & ',
        measles_model, " ",
        length(years), " ",
        tstep, " ",
        save_scenario, " ",
        foldername, " ",
        fortran_country_code, " ",
        p, " ",
        "WIN", " ",
        debug_debug, " ",
        debug_compartments, " ",
        debug_age, " ",
        debug_timepoints, " ",
        debug_relative
      )

      model <- gsub ("/", "\\\\", model)
      shell (model, intern = TRUE)

    } else {
      model <- paste0 (
        'cd "',
        'model/compiled/"; ./',
        measles_model, " ",
        length(years), " ",
        tstep, " ",
        save_scenario, " ",
        foldername, " ",
        fortran_country_code, " ",
        p, " ",
        "LIN", " ",
        debug_debug, " ",
        debug_compartments, " ",
        debug_age, " ",
        debug_timepoints, " ",
        debug_relative
      )
      system(model, intern=TRUE)
    }
  }

  dynamice:::writelog (log_name, paste0(iso3, "; Run ",r,"/",runs,"; Finished model"))
  # updateProgress (iso3, ii, runs, r, 3)

  # remove input data for this country
  # if files are removed around the same time by different workers, position may change
  if(remove_files){
    files <- list.files(
      paste0("./outcome/", save_scenario, "/",foldername,"/input/",psadir),
      pattern = iso3, full.names = TRUE
    )
    do.call(
      file.remove, list(
        files[
          grepl(
            fortran_country_code,
            files
          )
        ]
      )
    )
  }
} # end of function -- runCountry
# ------------------------------------------------------------------------------


# ------------------------------------------------------------------------------
#' Run the measles model for a selected vaccination strategy
#'
#' A function that execute the measles model under a selected vaccination
#' strategy, including a pre-specified set of countries and a set of probability
#' sensitivity analysis (PSA) runs.
#'
#' @param vaccine_coverage_folder A folder name for the vaccine coverage files.
#' @param vaccine_coverage_subfolder A folder name under the \code{x} folder for
#' the vaccine coverage files.
#' @param coverage_prefix A prefix used in naming the vaccine coverage file.
#' @param antigen Name of a disease: "Measles".
#' @param scenario_name Name of the vaccination strategy selected.
#' @param save_scenario A folder name for saving a selected scenario.
#' @param burden_estimate_folder A folder name for the file which contains the
#' model outputs for evaluation. Include a forward slash at the end.
#' @param group_name A modelling group name used by VIMC.
#' @param log_name A file name for keeping a log.
#' @param countries A vector of ISO-3 country codes used in the analysis. Use
#' "all" to include all countries.
#' @param cluster_cores Number of cores to be used for parallel computation.
#' @param psa A numeric variable of the total runs for PSA. Use 0 to indicate a
#' single run without PSA.
#' @param vaccination A numeric indicator that determines vaccination programmes
#'  for children: 0 - No vaccination, 1 - Only MCV1,  2 - MCV1 and MCV2.
#' @param using_sia A numeric indicator that determines whether supplementary
#' immunisation activities (SIAs) are implemented: 0 - no SIA, 1 - with SIA.
#' @param measles_model An executable file that processes Fortran codes of the
#' measles model.
#' @param debug_model A logical variable that determines whether to debug the
#' model.
#' @param contact_mat A character variable that indicates the assumptions for
#' contact patterns. "prpmix" - proportional mixing informed by age distribution
#' of population, "unimix" -  uniform mixing (equal mixing probability across
#' each age year), "polymod" - POLYMOD Great Britain physical contacts expanded
#' using local populations, and "syn" - country-specific synthetic matrix.
#' @param step_ve A logical variable that determines whether a step change on
#' age-related vaccine efficacy is applied. This implies different meaning of
#' vaccine efficacy vector (\code{take}) and a corresponding \code{measles_model}
#' should be applied.
#' @param sim_years A numeric vector containing calendar years included for model
#'  simulation.
#'
#' @import data.table
#' @import foreach
#'
#' @examples
#' \dontrun{
#' runScenario (
#'   vaccine_coverage_folder    = "vaccine_coverage_upd/",
#'   vaccine_coverage_subfolder = "scenarios/"
#'   coverage_prefix            = "coverage",
#'   antigen                    = "measles-",
#'   scenario_name              = "campaign-only-default",
#'   save_scenario              = scenario_number,
#'   burden_estimate_folder     = "central_burden_estimate/",
#'   group_name                 = NULL,
#'   log_name                   = "test_log",
#'   countries                  = c("BGD","ETH"),
#'   cluster_cores              = 3,
#'   psa                        = 0,
#'   vaccination                = 0,
#'   using_sia                  = 1,
#'   measles_model              = "vaccine2019_sia_singlematrix.exe",
#'   debug_model                = FALSE,
#'   contact_mat                = "prpmix",
#'   step_ve                    = FALSE,
#'   sim_years                  = 1980:2100
#'   )
#'   }
runScenario <- function (vaccine_coverage_folder    = "",
                         vaccine_coverage_subfolder = "",
                         coverage_prefix            = "",
                         antigen                    = "",
                         scenario_name,
                         save_scenario,
                         burden_estimate_folder,                  # burden estimate folder
                         group_name,                              # modelling group name
                         log_name,
                         countries                  = "all",
                         cluster_cores              = 1,
                         psa                        = 0,          # psa runs; 0 for single run
                         vaccination,  # Whether children are vaccinated. 0: No vaccination; 1: Only MCV1; 2: MCV1 and MCV2
                         using_sia,    # Whether supplementary immunization campaigns are used. 0: no SIA; 1: with SIA
                         measles_model,                           # measles model executive file
                         debug_model                = FALSE,      # debug model (T/F)
                         contact_mat,                             # contact matrix: "prpmix","polymod","syn"
                         step_ve,                                 # step change of take
                         sim_years                  = 1980:2023, # calendar years for simulation
                         filename

) {

  # changes 2019:
  #       a) add scenario folder pathname for clarity and for easier running on the cluster (fortran code changed too)
  #       b) change contact matrix to fix augumented mixing in <3 yo and to reflect country specific mixing (rescale polymod by local population structure to keep contacts reciprocal)
  #          - uses newly rescaled contact matrix to expand polymod to yearly ages up to 100
  #       c) time-varying CFRs (postprocessing)
  #       d) MCV1 and MCV2 dependency - give MCV2 to those who received MCV1 for MCV2 coverage <= MCV1, if MCV2 coverage > MCV1 distribute the remainder randomly
  #       e) MCV1 and SIA dependency - use linear regression of data from Portnoy et al 2018 to inform the proportion of zero-dose children reached by SIA campaign
  #       f) due to issues with age_range_verbatim field in the scenario (coverage) input files, these runs use age_first and age_last

  ages 		    <- c (0:100)	              # Numeric vector with age-strata that are reported (Model ALWAYS models 101 age-groups; 0-2yo in weekly age-strata, and 3-100yo in annual age-strata)
  psa 		    <- psa		                  # Number of PSAs to run (0 to use deterministic).

  # --------------------------------------------------------------------------
  # input data file names
  # --------------------------------------------------------------------------
  # vaccine coverage file for routine immunisation
  data_coverage_routine <- paste0 (vaccine_coverage_folder,
                                   vaccine_coverage_subfolder,
                                   "routine_",
                                   scenario_name,
                                   ".csv")

  # separate vaccine coverage file for SIA (supplementary immunisation activities)
  # data_coverage_sia <- paste0 (vaccine_coverage_folder,
  #                              vaccine_coverage_subfolder,
  #                              "sia_",
  #                              scenario_name,
  #                              ".csv")
  data_coverage_sia <- paste0 (vaccine_coverage_folder,
                               "scenarios/",
                               "sia_",
                               scenario_name,
                               ".csv")

  # data file name for PSA variables
  # same for each scenario. should be CREATED before simulation using CreatePSA_Data()
  data_psa 		<- "psa_variables.csv"


  # --------------------------------------------------------------------------
  # Advanced options
  # --------------------------------------------------------------------------

  sia.method	<- 1				             # 1 = variable take; 2 = variable degree
  dinf		    <- 14				             # duration of infection (days)
  amplitude 	<- 0.05			             # amplitude for seasonality

  # tack [3] : vaccine efficacy (dose2) and only has an effect if vaccine==2.
  # take [1:2] have different definitions, and should be used with corresponding measles models.

  {if (step_ve) {

    take 		  <- c (0.85, 0.95, 0.98)
    # take [1] # vaccine efficacy (dose 1, before age 1)
    # take [2] # vaccine efficacy (dose 1, after age 1)

  } else {

    take 		  <- c (0.64598, 0.01485, 0.98)
    # take [1] refers to vaceffbyage_a (intercept)
    # take [2] refers to vaceffbyage_b (slope)
  }}

  degree 		  <- c (0.85, 0.95, 0.98)    # vaccine efficacy for degree1 (degree dose 1, before age 1), degree2 (dose 1, after age 1) & degree3 (dose 2). Note that dose2 only has an effect if vaccine==2.
  tstep			  <- 1000				             # Number of time steps in a year
  gamma_tstep <- 1 / (dinf * tstep/365)  # rate of losing infectivity

  # number of clusters to use
  # if larger than 1, country-specific model runs are distributed over specified number of clusters
  # note that model uses a lot of memory, so might not want to max out all clusters
  use_cluster  <- cluster_cores   # debug #
  remove_files <- TRUE
  run_model    <- TRUE
  # folder will be created if not given - should usually be commented out, except when run model is FALSE


  # ------------------------------------------------------------------------------
  # Debug
  # ------------------------------------------------------------------------------
  debug_country		  <- "*"		    	#ISO3 codes of country to debug, * to debug all countries
  debug_spinup		  <- FALSE	    	#TRUE/FALSE: If true, generate data for spin-up period of model
  debug_model       <- debug_model	#TRUE/FALSE: If true: generate data for period after spin-up
  debug_compartments<- 1    	      #0-2: If 0: output number of cases. If 1: output size of each compartment. If 2: debug vaccinated
  debug_age         <- 0            #0-2. If 0: output all in annual age-strata. If 1: output age 0-2 in weekly age-strata, 3-100 in annual age-strata. If 2: sum all age-strata.
  debug_timepoints	<- 0			      #0-2. If 0: output per year. If 1: output per timepoint and report first 25% of timepoints. If 2: output per timepoint and report all timepoints.
  debug_relative		<- FALSE	    	#If true: output proportion of new cases. If false, output absolute number of new cases. Dose not affect compartments, which are always in proportions.


  # ----------------------------------------------------------------------------
  # START OF MODEL
  # ----------------------------------------------------------------------------

  # load correct libraries when on cluster (using open MPI)
  {if ("cluster_using_openmpi" %in% commandArgs()){
    using_openmpi <- TRUE
    # require(doMPI) to delete
   #  require(parallel)
    cl <- doMPI::startMPIcluster()
    doMPI::registerDoMPI(cl)
    print("using openMPI")
  } else {
    using_openmpi <- FALSE
    print("no openMPI")
  }}

  # clean environment
  {if (file.exists ("progress")) {
    file.remove ("progress")
  }}

  # are we running a PSA - a deterministic or "stochastic" model?
  {if (psa == 0) {
    det_stoch <- "deter" # deterministic
    runs      <- 1

  } else {
    det_stoch <- "stoch" # stochastic
    runs      <- psa
  }}

  # create folders with correct name for in- and output data if not yet exists
  # typically foldername should not exist - but may come in handy when only processing results
  {if ( !exists("foldername_analysis") ) {

    foldername <- paste0 (
      format(Sys.time(),format="%Y%m%d"),
      "_v",
      vaccination,
      "_s",
      using_sia,
      "_",
      det_stoch
    )

    dir.create(
      file.path(
        paste0(
          getwd(),
          "/outcome/", save_scenario, "/",
          foldername
        )
      ), recursive = T
    )

    dir.create(
      file.path(
        paste0(
          getwd(),
          "/outcome/", save_scenario, "/",
          foldername,
          "/input"
        )
      ), recursive = T
    )

    dir.create(
      file.path(
        paste0(
          getwd(),
          "/outcome/", save_scenario, "/",
          foldername,
          "/output"
        )
      ), recursive = T
    )

    if (psa > 0) {

      for(p in 1:psa){
        if(p<10){
          p <- paste0("00",p)
        } else if(p<100){
          p <- paste0("0",p)
        }

        dir.create(
          file.path(
            paste0(
              getwd(),
              "/outcome/", save_scenario, "/",
              foldername,
              "/input/",
              paste0("run",p)
            )
          ), recursive = T
        )

        dir.create(
          file.path(
            paste0(
              getwd(),
              "/outcome/", save_scenario, "/",
              foldername,
              "/output/",
              paste0("run",p)
            )
          ), recursive = T
        )
      }
    }
  } else {
    foldername <- foldername_analysis
  }}


  # ----------------------------------------------------------------------------
  # log
  # ----------------------------------------------------------------------------
  dynamice:::writelog (log_name, paste0("Main; Started"))

  {if (using_openmpi) {
    dynamice:::writelog (log_name, paste0 ("Main; OpenMPI enabled"))
  } else {
    dynamice:::writelog (log_name, paste0 ("Main; OpenMPI disabled"))
  }}

  # read_data
  coverage_routine	<- copy (fread (data_coverage_routine))[year %in% sim_years]
  coverage_sia		  <- copy (fread (data_coverage_sia))[year %in% sim_years]
  timeliness  		  <- setDT (data_timeliness)
  rnought	    		  <- setDT (data_r0) #setNames(as.list(data_r0$r0), data_r0$country_code)
  population  		  <- setDT (data_pop)
  template    		  <- setDT (data_template)


  # ----------------------------------------------------------------------------
  # pas variables
  # ----------------------------------------------------------------------------
  {if (psa > 0) {
    if (file.exists (data_psa)) {

      # read csv if file already exists
      psa_var <- fread (data_psa)

      # check if psa_var corresponds with psa
      if(nrow(psa_var) != psa){
        stop(paste0("Number of runs in PSA file is not the same as those specified! Variables used in the same run in each scenario should be similar. Delete or rename ",data_psa," if a new file needs to be created, or change the number of PSA runs to ",nrow(psa_var)," if the same file should be used."))
      }
    } else {
      stop(paste0("There is no files for inputting PSA variables. Use CreatePSA_Data() to generate the file."))
      }
  }}


  # ----------------------------------------------------------------------------
  # process data
  # ----------------------------------------------------------------------------

  # if countries are specified to all, then set countries to all countries in coverage file
  {if (countries[[1]] == "all") {
    countries	<- as.character (unique (coverage_routine [, country_code] ) )
  }}

  # start and end years (should go in as input to function -- INPUT-FUNCTION)
  years    <- as.numeric (sim_years)           # c(1980:2100)
  template <- template [year %in% years]       # adjust template based on simulation years

  for (cty in countries) {
    if (psa > 1){
      for (p in 1:psa){
        write(
          paste0(
            cty,
            " ",
            paste0(c(rep(0,(nchar(psa)-nchar(p))),p),collapse=""),
            " 0"
          ),
          file   = "progress",
          append = TRUE
        )
      }
    } else {
      write(
        paste0(
          cty,
          " ",
          "1 0"
        ),
        file   = "progress",
        append = TRUE
      )
    }
  }

  # Process contact matrices
  use_kenya <- "KEN"
  contact_list <- switch (contact_mat,
                          "syn"     = sapply (use_kenya, # countries
                                              function(cty){data_contact_syn[[cty]]},
                                              simplify = FALSE, USE.NAMES = TRUE),
                          "polymod" = sapply (use_kenya, # countries
                                              function(cty){data_contact_polymod[[cty]]},
                                              simplify = FALSE, USE.NAMES = TRUE),
                          "prpmix"  = sapply (use_kenya, # countries
                                              function(x = NULL){matrix (1/101, nrow = 101, ncol = 101)},
                                              simplify = FALSE, USE.NAMES = TRUE), # not actually used but to fit in the model structure
                          "unimix"  = sapply (use_kenya, # countries
                                              function(x = NULL){matrix (1/101, nrow = 101, ncol = 101)},
                                              simplify = FALSE, USE.NAMES = TRUE)
                          )


  # ----------------------------------------------------------------------------
  # Run model
  # ----------------------------------------------------------------------------
  dynamice:::writelog (log_name, paste0 ("Main; Foldername: ", foldername))

  {if (using_openmpi | use_cluster > 1){
    if (!using_openmpi){

      if (use_cluster != parallel::detectCores()) {
        warning (paste0(parallel::detectCores(), " cores detected but ", use_cluster, " specified."))
      }

      cl <- parallel::makeCluster (use_cluster)
      doParallel::registerDoParallel (cl)

    } else {
      print (paste0 ("Clustersize: ", doMPI::clusterSize(cl)))
    }
  }}


  # foreach will run countries and PSA runs in parallel if a parallel backend
  # is registered, and sequentially otherwise
  # require(foreach)
  # require(doParallel)
  # cl <- makeCluster(8)
  # registerDoParallel(cl)

  combine <-
    foreach (
      ii = 1:length(countries),
      .packages = c("data.table", "dplyr"),
      .errorhandling = "stop", # "pass
      .export = c("runCountry", "writelog", "expandMatrix")) %:%
    # .export = c("runCountry", "writelog", "expandMatrix", "updateProgress")) %:%
    foreach (
      r = 1:runs,
      .errorhandling = "stop") %dopar% {
        iso3    <- countries[ii]
        out_run <- runCountry (ii                 = ii,
                               iso3               = iso3,
                               years              = years,
                               vaccination        = vaccination,
                               using_sia          = using_sia,
                               dinf               = dinf,
                               gamma_tstep        = gamma_tstep,
                               amplitude          = amplitude,
                               take               = take,
                               degree             = degree,
                               sia.method         = sia.method,
                               c_coverage_routine = coverage_routine[country_code == iso3,],
                               c_coverage_sia     = coverage_sia[country_code == iso3 & coverage != 0,],
                               c_timeliness       = timeliness[country_code == iso3,],
                               contact_mat        = contact_mat,
                               c_contact          = contact_list[["KEN"]], #*make it use KEN | original: contact_list((iso3))
                               c_rnought          = rnought[country_code == iso3, r0], #rnought[[countries[ii]]],
                               c_population       = population[country_code == iso3,],
                               tstep              = tstep,
                               save_scenario      = save_scenario,
                               foldername         = foldername,
                               log_name           = log_name,
                               measles_model      = measles_model,
                               debug_model        = debug_model,
                               debug_spinup       = debug_spinup,
                               debug_age          = debug_age,
                               debug_compartments = debug_compartments,
                               debug_country      = debug_country,
                               debug_relative     = debug_relative,
                               debug_timepoints   = debug_timepoints,
                               r                  = r,
                               runs               = runs,
                               psa                = psa,
                               psa_var            = psa_var,
                               run_model          = run_model,
                               remove_files       = remove_files
        )
        return(out_run)

      }

    #* {if (!using_openmpi){
    #*   parallel::stopCluster(cl)
    #* } else {
    #*   doMPI::closeCluster(cl)
    #* }}

  # check for errors
  errorcount <- 0

  for (i in 1:length(combine)){
    if ("error" %in% class(combine[[i]])){
      errormessage <- paste0 ("Error in task ", i, ": ", combine[[i]])
      warning(errormessage)
      dynamice:::writelog (log_name, errormessage)
      errorcount <- errorcount + 1
      #remove from data
      combine[[i]] <- NULL
    }
  }
  # if(errorcount > 0){
  # stop(paste0("There were ",errorcount," errors."))
  # }


  # ----------------------------------------------------------------------------
  # process results
  # ----------------------------------------------------------------------------
  report_years <- sort (unique (template$year))

  # ANALYSE RUNS

  # get the names of all the files in all the subfolders the stochastic runs
  # specified in scenarioname; separate cases and popsize files
  # will use those to read them all in at once and put in a data.table
  myfiles <- list.files (path = paste0 ("outcome/", save_scenario, "/",foldername,"/output/"),
                         recursive = T, pattern = "cases", full.names = T)
  myfiles.popsize <- list.files (path = paste0 ("outcome/", save_scenario, "/",foldername,"/output"),
                                 recursive = T, pattern = "popsize", full.names = T)

  # read in all those files specified in myfiles and put them in a single data table
  all_cases  <- rbindlist (lapply (myfiles, function (fn, ...) {
    res <- withCallingHandlers (
      fread (fn, stringsAsFactors = F, check.names = F, fill = T,
             col.names = as.character (c(0:100))),
      warning = function(w) {warning(w, fn); }
      )
    res[, country := gsub ("^.+/(\\w+)_age.+$","\\1", fn)]             # get the country code from the filename
    # get run_id for psa runs
    if (psa > 0) {
      res[, run_id := as.integer (gsub("^.+run(\\d{3}).+$","\\1", fn))]  # get the run_id from the filename (subfolder)
    }
    res[, year := years]                                               # add year of simulation (from coverage data file)
  }))

  # switch back Kosovo to XK otherwise montagu returns error on upload
  all_cases[country == "XKX", country := "XK"]

  all_popsize  <- rbindlist (lapply (myfiles.popsize, function (fn, ...) {
    res <- fread (fn, stringsAsFactors = F, check.names = F, col.names = as.character(c(0:100)))
    res[, country := gsub("^.+/(\\w+)_age.+$","\\1", fn) ]                # get the country code from the filename
    if (psa > 0) {
      res[, run_id := as.integer (gsub("^.+run(\\d{3}).+$","\\1", fn)) ]  # get the run_id from the filename (subfolder)
    }
    res[, year := years]                                                  # add year of model was run for (from coverage data file)
  }))
  all_popsize[country == "XKX", country := "XK"]

  {if (psa > 0) {
    column_names <- c("year", "country", "run_id")
  } else {
    column_names <- c("year", "country")
  }}

  # all_cases.m <- melt(all_cases, id.vars = c("year","country"),
  all_cases.m <- melt (all_cases, id.vars = column_names,
                       measure.vars = c(as.character(0:100)),
                       variable.name = "age", value.name = "cases", variable.factor = F)

  # all_popsize.m <- melt(all_popsize, id.vars = c("year", "country"),
  all_popsize.m <- melt (all_popsize, id.vars = column_names,
                         measure.vars = c(as.character(0:100)),
                         variable.name = "age", value.name = "cohort_size", variable.factor = F)

  # melt produces character variable when variable.factor is set to FALSE - change it to integer
  all_cases.m   [, age := lapply(.SD, as.integer), .SDcols = "age"]
  all_popsize.m [, age := lapply(.SD, as.integer), .SDcols = "age"]

  # merge cases and cohort sizes
  all_runs = merge (all_cases.m, all_popsize.m, by = c(column_names, "age"), all.x = T)

  # add country_name, life expectancy and disease (Measles) to match template file
  country_names <- unique (subset (template, select = c("country", "country_name")))
  c_names <- country_names$country_name; names(c_names) = country_names$country

  all_runs[, c("country_name", "disease") := list (c_names[country], "Measles")]

  # add data column for remaining life expectancy
  lexp_remain <- tailor_data_lexp_remain(countries)

  {if (psa > 0) {
    all_runs <- lexp_remain [all_runs,
                                  .(run_id, i.country, year, age, cases, cohort_size, country_name, disease, value),
                                  on = .(country_code = country,
                                         age          = age,
                                         year         = year) ]
  } else {
    all_runs <- lexp_remain [all_runs,
                                  .(i.country, year, age, cases, cohort_size, country_name, disease, value),
                                  on = .(country_code = country,
                                         age          = age,
                                         year         = year) ]
  }}

  # rename column names for output
  setnames (all_runs,
            old = c("i.country", "value"      ),
            new = c("country"  , "remain_lexp"))


  # add data column for MCV1 coverage
  coverage_routine_MCV1 <- coverage_routine [vaccine == "MCV1"]

  {if (psa > 0) {
    all_runs <- coverage_routine_MCV1 [all_runs,
                                       .(run_id, i.country, i.year, age, cases, cohort_size, country_name, disease, coverage, remain_lexp),
                                       on = .(country_code = country,
                                              year         = year) ]
  } else {
    all_runs <- coverage_routine_MCV1 [all_runs,
                                       .(i.country, i.year, age, cases, cohort_size, country_name, disease, coverage, remain_lexp),
                                       on = .(country_code = country,
                                              year         = year) ]
  }}

  # rename column "coverage" to "MCV1"
  setnames (x = all_runs,
            old = c("i.country", "i.year", "coverage"),
            new = c("country"  , "year"  , "MCV1"    ))

  # ----------------------------------------------------------------------------
  # # Not in use 2021:
  # # Previous methods for calculating deaths and dalys.
  # # Additional input data for CFR and life expectancy at birth are needed to recover.
  # all_runs[, deaths := cases * cfr.value]
  # all_runs[, dalys := (cases - deaths)*0.002 + deaths*(LE0 - 4)]       # assumes all deaths are age 4
  # all_runs[, dalys := (cases - deaths) * 0.002 + deaths * (LE0 - age)] # to account for actual age of death
  # ----------------------------------------------------------------------------
  # YLL calculation above is fine since most measles burden < 5 years
  # remaining life expectancy estimation can be improved by using remaining life
  # years by age, year and country
  # ----------------------------------------------------------------------------


  # ----------------------------------------------------------------------------
  # OUTPUT RUNS
  # ----------------------------------------------------------------------------
  # keep all columns
  output_runs <- subset (all_runs, year %in% report_years)

  # burden estimate type -- central or stochastic
  {if (psa > 0) {
    burden_estimate_type <- "stochastic_burden_estimate_"
  } else {
    burden_estimate_type <- "central_burden_estimate_"
  }}

  # burden estimate filename
  # burden_estimate_file <- paste0 (burden_estimate_type,
  #                                 antigen,
  #                                 group_name,
  #                                 scenario_name,
  #                                 ".csv")
  burden_estimate_file <- filename # my own addition

  # save burden estimates to file
  fwrite (x    = output_runs [order (country, year, age)],
          file = paste0 (burden_estimate_folder,  burden_estimate_file))

  # clean environment
  dynamice:::writelog (log_name, paste0 ("Main; Finished"))

  {if (using_openmpi) {
    Rmpi::mpi.quit()
  }}

  # return burden estimate filename (cases)
  return (burden_estimate_file)

} # end of function -- runScenario
# ------------------------------------------------------------------------------


# ------------------------------------------------------------------------------
#' Estimate deaths and DALYs of measles
#'
#' A function that estimates the number of deaths by applying case fatality
#' rates (CFRs) to the number of cases, and then calculates the
#' disability-adjusted years (DALYs)
#'
#' @param cfr_option Methods for CFR estimates: "Wolfson" or/and "Portnoy".
#' @param burden_estimate_file File name for model outputs to be saved.
#' @param burden_estimate_folder Folder name where \code{burden_estimate_file} is
#'  saved. Include a forward slash at the end.
#' @param vimc_scenario Name for vaccine strategy used in \code{data_cfr_portnoy.rda},
#'  for extracting CFR estimates by the Portnoy method.
#' @param portnoy_scenario Scenario name for future CFR trends used in the
#' Portnoy method: "s4" - declining after 2018, or "s6" - staying stagnant at
#' the 2018 level.
#' @param psa A numeric variable of the total runs for PSA. Use 0 to indicate a
#' single run without PSA (central estimate).
#'
#' @import data.table
#'
#' @examples
#' \dontrun{
#' estimate_deaths_dalys (
#'  cfr_option             = "Portnoy",
#'  burden_estimate_file   = burden_estimate_file,
#'  burden_estimate_folder = "central_burden_estimate/",
#'  vimc_scenario          = "campaign-only",
#'  portnoy_scenario       = "s6",
#'  psa                    = 0
#'  )
#'  }
# ------------------------------------------------------------------------------
#   save results in corresponding cfr_option subfolder
#   append cfr_option to burden estimates file
# ------------------------------------------------------------------------------
estimate_deaths_dalys <- function (cfr_option,
                                   burden_estimate_file,
                                   burden_estimate_folder,
                                   vimc_scenario,
                                   portnoy_scenario,
                                   psa = 0
                                   ) {

  # read burden estimates (primarily cases)
  burden <- fread (file = paste0 (burden_estimate_folder,
                                  burden_estimate_file) )

  {if (psa > 0) {
    psa_var	<- fread("psa_variables.csv")
  }}

  # ----------------------------------------------------------------------------
  # use CFRs -- Wolfson
  # ----------------------------------------------------------------------------
  if (cfr_option == "Wolfson") {

    # read CFRs  -- Wolfson
    kenya_wolfson_val <-data_cfr_wolfson |> filter(country == "Kenya") |> pull(CFR)
    cfr = setDT (data_cfr_wolfson) |>
      bind_rows(
        burden |> select(country_code = country, country = country_name) |> distinct() |>
          mutate(CFR = kenya_wolfson_val)
      ) |>
      distinct()

    # cfr estimates for ages below 5 years, not varying by time
    # cfrs for ages above 5 years are half the cfr values for ages below 5 years

    # add CFR data column to burden estimates
    if (psa > 0) {
      burden <- cfr [burden,
                     .(run_id, disease, year, age, i.country, country_name, cohort_size, cases, CFR, remain_lexp),
                     on = .(country_code = country) ]
      burden <- burden [psa_var[, .(run_id, mortality_input)], on = .(run_id = run_id)]
    } else {
      burden <- cfr [burden,
                     .(disease, year, age, i.country, country_name, cohort_size, cases, CFR, remain_lexp),
                     on = .(country_code = country) ]
    }

    # estimate deaths
    # cfrs for ages above 5 years are half the cfr values for ages below 5 years
    if (psa > 0) {
      burden [age <  5, deaths := cases * CFR     * mortality_input]
      burden [age >= 5, deaths := cases * (CFR/2) * mortality_input]
    } else {
      burden [age <  5, deaths := cases * CFR  ]
      burden [age >= 5, deaths := cases * CFR/2]
    }

    # rename country column
    setnames (burden, old = "i.country", new = "country")
  }


  # ----------------------------------------------------------------------------
  # use CFRs -- Portnoy
  # ----------------------------------------------------------------------------

  if (cfr_option == "Portnoy") {

    # read CFRs (rates between 0 and 1) -- Portnoy
    temp_counties <- NULL
    temp_kenya <- data_cfr_portnoy |> filter(country_name == "Kenya")
    u_code <- unique(burden$country)
    u_name <- unique(burden$country_name)
    for (i in 1:length(u_code)) {
      temp_counties <- bind_rows(temp_counties,
                                 temp_kenya |>
                                   mutate(country_name = u_name[i],
                                          country_code = u_code[i]))
    }


    #* cfr = setDT (data_cfr_portnoy)
    cfr = setDT (temp_counties)

    # cfr estimates are for 2000 to 2030
    # if cfr estimates are required for years below or above this range, then
    # for years below 2000, set cfr estimates of year 2000
    # for years above 2030, set cfr estimates of year 2030

    # find minimum and maximum year
    min_year = min (burden [, year])
    max_year = max (burden [, year])

    # set cfrs for years before 2000 to cfr values of year 2000
    {if (min_year < 2000) {
      cfr.year <- rbindlist (lapply (min_year:1999, function(i) copy (cfr [year == 2000, ])[, year := i]))
      cfr      <- rbind     (cfr.year, cfr, use.names = TRUE)
    }}

    # set cfrs after 2030 to 2030
    {if (max_year > 2030) {
      cfr.year <- rbindlist (lapply (2031:max_year, function(i) copy (cfr [year == 2030, ])[, year := i]))
      cfr      <- rbind     (cfr, cfr.year, use.names = TRUE)
    }}

    # rename columns -- cfr of vimc_scenario and portnoy_scenario
    # cfrs for under 5 (< 5) and over 5 (>= 5) years
    setnames (x = cfr,
              old = c(paste0 ("cfr_under5_", vimc_scenario, "_", portnoy_scenario),
                       paste0 ("cfr_over5_" , vimc_scenario, "_", portnoy_scenario)),
              new = c("under5", "over5"))

    # add CFR data column to burden estimates
    if (psa > 0) {
      burden <- cfr [burden,
                     .(run_id, disease, year, age, country, country_name, cohort_size, cases, over5, under5, remain_lexp),
                     on = .(country_code = country,
                            year         = year) ]
      burden <- burden [psa_var[, .(run_id, mortality_input)], on = .(run_id = run_id)]
    } else {
      burden <- cfr [burden,
                     .(disease, year, age, country, country_name, cohort_size, cases, over5, under5, remain_lexp),
                     on = .(country_code = country,
                            year         = year) ]
    }

    # estimate deaths for ages under 5 years and over 5 years
    if (psa > 0) {
      burden [age <  5, deaths := cases * under5 * mortality_input]
      burden [age >= 5, deaths := cases * over5  * mortality_input]
    } else {
      burden [age <  5, deaths := cases * under5]
      burden [age >= 5, deaths := cases * over5 ]
    }
  }

  # ----------------------------------------------------------------------------
  # DALYs
  # ----------------------------------------------------------------------------
  # calculate dalys = (ylds) + (ylls)
  burden [, dalys := ((cases - deaths) * 0.002) + (deaths * remain_lexp)]

  # adjust columns for output
  if (psa > 0) {
    save.cols <- c("run_id", names(data_template))
  } else {
    save.cols <- names(data_template)
  }
  burden <- subset (burden, select = save.cols)

  # append/suffix cfr_option to the end of filename
  updated_burden_estimate_file <- stringr::str_replace (string      = burden_estimate_file,
                                                        pattern     = ".csv",
                                                        replacement = paste0 ("_", cfr_option, ".csv")
  )

  # save updated burden estimate file (cases + deaths) to file
  # cfr_option is also the name of the subfolder
  fwrite (x    = burden,
          file = paste0 (burden_estimate_folder,
                         cfr_option, "/",
                         updated_burden_estimate_file)
  )
  return ()
} # end of function -- estimate_deaths_dalys
# ------------------------------------------------------------------------------

